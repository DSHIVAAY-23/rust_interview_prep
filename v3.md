# AssetTokenV2.sol (Blacklist Upgrade)

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./AssetToken.sol";

/**
 * @title AssetTokenV2
 * @notice V2 Upgrade: Adds Blacklist functionality
 * @dev Inherits AssetToken to preserve storage layout of V1.
 * New variables MUST be appended at the end.
 */
contract AssetTokenV2 is AssetToken {
    
    // --- 1. NEW STORAGE (Appended at the end) ---
    // In upgradeable contracts, you cannot change the order of existing variables.
    // You can only ADD new ones at the bottom to avoid corrupting memory.
    mapping(address => bool) private _blacklist;

    // --- 2. EVENTS ---
    event UserBlacklisted(address indexed user);
    event UserUnblacklisted(address indexed user);

    // --- 3. ERROR ---
    // Custom error saves gas compared to require strings
    error AccountBlacklisted(address account);

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    // NOTE: We do NOT need an initialize() function here because mappings 
    // default to empty (false), which is the correct initial state for a blacklist.

    // --- 4. ADMIN FUNCTIONS ---

    /**
     * @notice Blocks or Unblocks a user
     * @dev Only callable by Admin. 
     */
    function setBlacklistStatus(address account, bool status) public onlyRole(DEFAULT_ADMIN_ROLE) {
        _blacklist[account] = status;
        if (status) {
            emit UserBlacklisted(account);
        } else {
            emit UserUnblacklisted(account);
        }
    }

    /**
     * @notice Check if a user is blacklisted
     */
    function isBlacklisted(address account) public view returns (bool) {
        return _blacklist[account];
    }

    // --- 5. THE LOGIC HOOK (Override) ---

    /**
     * @dev Hooks into the transfer lifecycle to enforce the blacklist.
     * In OpenZeppelin v5, _update replaces _beforeTokenTransfer.
     * This single function blocks Minting, Burning, and Transfers for blacklisted users.
     */
    function _update(
        address from,
        address to,
        uint256 value
    ) internal override {
        // Check Sender (unless minting, where from is 0x0)
        if (from != address(0) && _blacklist[from]) {
            revert AccountBlacklisted(from);
        }
        // Check Receiver (unless burning, where to is 0x0)
        if (to != address(0) && _blacklist[to]) {
            revert AccountBlacklisted(to);
        }

        // Call the parent (V1) update logic to actually move tokens
        super._update(from, to, value);
    }
}
